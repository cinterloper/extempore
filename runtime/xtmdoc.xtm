;;;;;;;;;;;;
;; xtmdoc ;;
;;;;;;;;;;;;

;; the documentation function should return an associative list with
;; the following keys:

;; ((name . awesome_closure)
;;  (category . "closure")
;;  (type . "[i64]")
;;  (args . (arg1 arg2))
;;  (docstring . "the docstring))

;; the keys must be present, but the cdr of each element may be
;; missing where appropriate (e.g. scheme functions have no type field)

(define xtmdoc-strip-arg-type-annotations
  (lambda (form)
    (if (or (symbol? form)
            (not (list? form)))
        form
        (map (lambda (arg)
               (string->symbol (car (regex:split (symbol->string arg) ":"))))
             form))))

(define xtmdoc-get-args-from-form
  (lambda (form)
    (if (null? form)
        #f
        (if (equal? (car form) 'lambda)
            (xtmdoc-strip-arg-type-annotations (cadr form))
            (if (and (list? (car form)) (equal? (caar form) 'lambda))
                (xtmdoc-strip-arg-type-annotations (cadar form))
                ;; recurse!
                (xtmdoc-get-args-from-form (if (member (car form) '(let let* letz))
                                               (cddr form)
                                               (cdr form))))))))

;; currently only returns the result for the first arity
(define xtmdoc-get-xtlang-genericfunc-args
  (lambda (fn-sym)
    (xtmdoc-get-args-from-form
     (caddar (cdddar (assoc-strcmp-all fn-sym *impc:ti:genericfunc-cache*))))))

(define xtmdoc-builtin-handler
  (lambda (name-sym)
    (list
     '(category . "builtin")
     (cons 'name (symbol->string name-sym))
     (cons 'args (impc:ti:get-builtin-args (symbol->string name-sym)))
     (cons 'type
           (let ((type (impc:ti:get-builtin-type-str (symbol->string name-sym))))
             (if (string=? type "") '() type)))
     (cons 'docstring
           (let ((docstring (impc:ti:get-builtin-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-genericfunc-handler
  (lambda (name-sym)
    ;; once we have a way to handle multipe aritys, we should update
    ;; this function
    (list
     '(category . "generic closure")
     (cons 'name (symbol->string name-sym))
     (cons 'args (xtmdoc-get-xtlang-genericfunc-args name-sym))
     (cons 'type (impc:ti:simplify-genericfunc-pretty-type
                  (symbol->string (caddar (assoc-strcmp-all name-sym *impc:ti:genericfunc-cache*)))))
     (list 'docstring))))

(define xtmdoc-generictype-handler
  (lambda (name-sym)
    (list
     '(category . "generic type")
     (cons 'name (symbol->string name-sym))
     (list 'args)
     (cons 'type (impc:ti:simplify-generictype-pretty-type
                  (symbol->string (impc:ti:get-generictype-candidate-types name-sym))))
     (list 'docstring))))

(define xtmdoc-polyfunc-handler
  (lambda (name-sym)
    (list
     '(category . "polymorphic closure")
     (cons 'name (symbol->string name-sym))
     (cons 'args "")
     (list 'type)
     (cons 'docstring
           (let ((docstring (impc:ti:get-polyfunc-docstring (symbol->string name-sym)))
                 (poly-options-docstring
                  (string-join (map (lambda (pf)
                                      (let* ((option-name (vector-ref pf 0)))
                                        (string-append "@poly " option-name ":"
                                                       (impc:ir:pretty-print-type (vector-ref pf 1)))))
                                    (cl:remove-if
                                     (lambda (pf) (regex:match? (vector-ref pf 0) "_poly_"))
                                     (impc:ti:get-polyfunc-candidate-list (symbol->string name-sym))))
                               "\n")))
             (string-append docstring "\n\n" poly-options-docstring))))))

(define xtmdoc-polytype-handler
  (lambda (name-sym)
    (list
     '(category . "polymorphic type")
     (cons 'name (symbol->string name-sym))
     (list 'args)
     (cons 'type (string-join (map (lambda (pf) (impc:ir:pretty-print-type pf))
                                   (impc:ti:get-polytype-candidate-types (symbol->string name-sym)))
                              " "))
     (list 'docstring))))

(define xtmdoc-closure-handler
  (lambda (name-sym)
    (list
     '(category . "closure")
     (cons 'name (symbol->string name-sym))
     (cons 'args (xtmdoc-get-args-from-form (impc:ti:get-closure-body (symbol->string name-sym))))
     (cons 'type (impc:ir:pretty-print-type (impc:ti:get-closure-type (symbol->string name-sym))))
     (cons 'docstring
           (let ((docstring (impc:ti:get-closure-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-nativefunc-handler
  (lambda (name-sym)
    (list
     '(category . "C function")
     (cons 'name (symbol->string name-sym))
     (cons 'args (impc:ti:get-nativefunc-arg-names (symbol->string name-sym)))
     (cons 'type
           (let ((type (impc:ti:get-nativefunc-type (symbol->string name-sym))))
             (if (equal? type 'varargs)
                 "varargs"
                 (impc:ir:pretty-print-type type))))
     (cons 'docstring
           (let ((docstring (impc:ti:get-nativefunc-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-typealias-handler
  (lambda (name-sym)
    (list
     '(category . "type alias")
     (cons 'name (symbol->string name-sym))
     (list 'args)
     (cons 'type (impc:ir:pretty-print-type (impc:ti:get-typealias-ground-type (symbol->string name-sym))))
     (cons 'docstring
           (let ((docstring (impc:ti:get-typealias-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-namedtype-handler
  (lambda (name-sym)
    (list
     '(category . "named type")
     (cons 'name (symbol->string name-sym))
     (list 'args)
     (cons 'type (impc:ir:pretty-print-type (impc:ti:get-namedtype-type (symbol->string name-sym))))
     (cons 'docstring
           (let ((docstring (impc:ti:get-namedtype-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-globalvar-handler
  (lambda (name-sym)
    (list
     '(category . "global var")
     (cons 'name (symbol->string name-sym))
     (list 'args)
     ;; rememeber that global vars need to be "depointerised" by one level
     (cons 'type (impc:ir:pretty-print-type (impc:ir:pointer-- (impc:ti:get-globalvar-type (symbol->string name-sym)))))
     (cons 'docstring
           (let ((docstring (impc:ti:get-globalvar-docstring (symbol->string name-sym))))
             (if (string=? docstring "") '() docstring))))))

(define xtmdoc-scheme-function-handler
  (lambda (name-sym)
    (list
     '(category . "scheme closure")
     (cons 'name (symbol->string name-sym))
     (cons 'args (xtmdoc-get-args-from-form (get-closure-code (eval name-sym))))
     (list 'type)
     (list 'docstring))))

(define xtmdoc-scheme-macro-handler
  (lambda (name-sym)
    (list
     '(category . "scheme macro")
     (cons 'name (symbol->string name-sym))
     (cons 'args (cadadr (caddr (get-closure-code (eval name-sym)))))
     (list 'type)
     (list 'docstring))))

(define xtmdoc-documentation-function
  (lambda (name)
    (let ((sym (string->symbol name)))
      (cond ((impc:ti:builtin-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-builtin-handler sym)))
            ((impc:ti:typealias-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-typealias-handler sym)))
            ((impc:ti:genericfunc-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-genericfunc-handler sym)))
            ((impc:ti:polyfunc-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-polyfunc-handler sym)))
            ((impc:ti:closure-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-closure-handler sym)))
            ((impc:ti:nativefunc-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-nativefunc-handler sym)))
            ((impc:ti:globalvar-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-globalvar-handler sym)))
            ((impc:ti:generictype-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-generictype-handler sym)))
            ((impc:ti:polytype-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-polytype-handler sym)))
            ((impc:ti:namedtype-exists? name)
             (cons 'xtmdoc-docstring (xtmdoc-namedtype-handler sym)))
            ((and (defined? sym) (closure? (eval sym)))
             (cons 'xtmdoc-docstring (xtmdoc-scheme-function-handler sym)))
            ((and (defined? sym) (macro? (eval sym)))
             (cons 'xtmdoc-docstring (xtmdoc-scheme-macro-handler sym)))
            (else
             '(xtmdoc-docstring-nodocstring))))))

;; sort the alists (as returned by the various handler functions) into
;; a reasonably meaningful order (least to most important)
(define xtmdoc-alist-lessthan
  (lambda (left right)
    (let ((categories '("C function"
                        "global var"
                        "polymorphic closure"
                        "polymorphic type"
                        "closure"
                        "named type"
                        "generic closure"
                        "generic type"
                        "type alias"
                        "builtin")))
      (let ((lpos (cl:position (cdr (assoc-strcmp 'category left)) categories))
            (rpos (cl:position (cdr (assoc-strcmp 'category right)) categories)))
        (if (<> lpos rpos)
            (< lpos rpos)
            (string<? (cdr (assoc-strcmp 'name left))
                      (cdr (assoc-strcmp 'name right))))))))

(define xtmdoc-clean-nativefunc-alist
  (lambda (closure-alists nativefunc-alists)
    (cl:remove-if
     (lambda (nativefunc-data)
       (let ((nativefunc-name (cdr (assoc-strcmp 'name nativefunc-data))))
         (cl:find-if (lambda (closure-data)
                       ;; is it a closure?
                       (string=? (cdr (assoc-strcmp 'name closure-data)) nativefunc-name))
                     closure-alists)))
     nativefunc-alists)))

(define xtmdoc-all-doc-alists
  (lambda (include-nativefuncs?)
    (let* ((closure-alists
            (map (lambda (data) (xtmdoc-closure-handler (string->symbol (car data))))
                 *impc:ti:closure-cache*))
           (all-doc-alists
            (append
             (map (lambda (data) (xtmdoc-builtin-handler (string->symbol (car data)))) *impc:ti:builtin-cache*)
             (map (lambda (data) (xtmdoc-typealias-handler (string->symbol (car data)))) *impc:ti:typealias-cache*)
             (map (lambda (data) (xtmdoc-generictype-handler (car data))) *impc:ti:generictype-cache*)
             (map (lambda (data) (xtmdoc-genericfunc-handler (car data))) *impc:ti:genericfunc-cache*)

             (map (lambda (data) (xtmdoc-namedtype-handler (string->symbol (car data)))) *impc:ti:namedtype-cache*)
             closure-alists
             (map (lambda (data) (xtmdoc-polytype-handler (string->symbol (car data)))) *impc:ti:polytype-cache*)
             (map (lambda (data) (xtmdoc-polyfunc-handler (string->symbol (car data)))) *impc:ti:polyfunc-cache*)
             (map (lambda (data) (xtmdoc-globalvar-handler (string->symbol (car data)))) *impc:ti:globalvar-cache*)
             ;; make sure the "_native" versions of each closure don't get in
             ;; there (since the closure is already there)
             (if include-nativefuncs?
                 (xtmdoc-clean-nativefunc-alist
                  closure-alists
                  (map (lambda (x)
                         (xtmdoc-nativefunc-handler (string->symbol (car x))))
                       *impc:ti:nativefunc-cache*))
                 '()))))
      ;; filter out the things which shouldn't make it to the exported docs
      (cl:remove-if
       (lambda (doc-alist)
         (regex:match? (cdr (assoc-strcmp 'name doc-alist))
                       "(_setter$|_scheme$|_native$|_maker$|_getter$|_callback$|_poly_)"))
       all-doc-alists))))

;; we handle the args field separately, since there are a few special
;; cases to handle
(define xtmdoc-write-alist-args-as-json
  (lambda (xtmdoc-alist file-port)
    ;; (println (cdr (assoc-strcmp 'name xtmdoc-alist)))
    (display ",\n  \"args\": " file-port)
    (let ((category (cdr (assoc-strcmp 'category xtmdoc-alist)))
          (args (cdr (assoc-strcmp 'args xtmdoc-alist)))
          (type (cdr (assoc-strcmp 'type xtmdoc-alist))))
      ;; arg names and types
      (cond
       ((member category '("closure" "generic closure"))
        (display
         (string-append
          "["
          (string-join (map (lambda (name type)
                              (string-append "[\"" (symbol->string name) "\", \"" type "\"]"))
                            (cons 'RETURN args)
                            (impc:ir:get-pretty-closure-arg-strings type))
                       ", ")
          "]")
         file-port))
       ((string=? category "builtin")
        (if (or (not (string? type))
                (string=? type "")
                (<> (length (cdr (impc:ir:get-pretty-closure-arg-strings type)))
                    (length args)))
            ;; allow builtins have malformed arg/type relationships
            (display
             (string-append
              "["
              (string-join (map (lambda (name)
                                  (string-append "[\"" (symbol->string name) "\", null]"))
                                args)
                           ", ")
              "]")
             file-port)
            (display
             (string-append
              "["
              (string-join (map (lambda (name type)
                                  (string-append "[\"" (symbol->string name) "\", \"" type "\"]"))
                                (cons 'RETURN args)
                                (impc:ir:get-pretty-closure-arg-strings type))
                           ", ")
              "]")
             file-port)))
       ((string=? category "C function")
        (display
         (string-append
          "["
          ;; at the moment, there's no way of telling the xtlang
          ;; compiler about the names of the arguments to a C function
          (string-join (map (lambda (type)
                              (string-append "[null, \"" type "\"]"))
                            (impc:ir:get-pretty-closure-arg-strings type))
                       ", ")
          "]")
         file-port))
       ;; these are the ones for which "args" doesn't make sense
       ;; "named type"
       ;; "generic type"
       ;; "polymorphic closure"
       ;; "global var"
       ;; "polymorphic type"
       ;; "type alias"
       (else (write 'null file-port))))))

(define xtmdoc-write-alist-as-json
  (lambda (xtmdoc-alist file-port)
    (display "{\n  \"category\": " file-port)
    (write (cdr (assoc-strcmp 'category xtmdoc-alist)) file-port)
    (display ",\n  \"name\": " file-port)
    (write (cdr (assoc-strcmp 'name xtmdoc-alist)) file-port)
    (xtmdoc-write-alist-args-as-json xtmdoc-alist file-port)
    (display ",\n  \"type\": " file-port)
    (let ((type (cdr (assoc-strcmp 'type xtmdoc-alist))))
      (write (if (null? type) 'null type) file-port))
    (display ",\n  \"docstring\": " file-port)
    (let ((docstring (cdr (assoc-strcmp 'docstring xtmdoc-alist))))
      (write (if (null? docstring) 'null docstring) file-port))
    (display "\n}" file-port)))

(define xtmdoc-export-caches-to-json
  (lambda (file-path include-nativefuncs?)
    (let ((outfile-port (open-output-file file-path)))
      (display "[\n" outfile-port)
      (let loop ((doc-alists (cl:sort (xtmdoc-all-doc-alists include-nativefuncs?)
                                      (lambda (a b) (not (xtmdoc-alist-lessthan a b))))))
        (if (null? doc-alists)
            (begin
              (display "\n]" outfile-port)
              (close-port outfile-port)
              (print "Succesfully exported docs as json to " file-path "\n")
              #t)
            (begin
              (xtmdoc-write-alist-as-json (car doc-alists) outfile-port)
              (if (not (null? (cdr doc-alists)))
                  (display ",\n" outfile-port))
              (loop (cdr doc-alists))))))))
